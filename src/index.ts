import { app, BrowserWindow } from 'electron';
import { httpServer, checkSchedule } from './server';


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
let mainWindow: BrowserWindow;
let checkScheduleInterval:any = undefined;

const PORT = 80;
const HOST = "0.0.0.0";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    frame: false,
    fullscreen: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },

  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.maximize();
  // Open the DevTools.
  //mainWindow.webContents.openDevTools();
  if(mainWindow !== undefined) {
    mainWindow.webContents.send("schedule-change", "alma");
  }
  
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', initApp);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  //if (process.platform !== 'darwin') {
    app.quit();
  //}

});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    initApp();
  }
});

httpServer.listen(PORT, HOST);
httpServer.on('error', (e:any) => {
  if (e.code === 'EADDRINUSE') {
    console.error('Address in use, retrying...');
    setTimeout(() => {
      httpServer.listen(PORT, HOST);
    }, 1000);
  }
});


function initApp() {
  if (checkScheduleInterval === undefined) {
    checkScheduleInterval = setInterval(checkSchedules, 1000);
  }
  createWindow();
}

const PRIORITY_SCHEDULE_INDUEX = 7;
const GENERAL_SCHEDULE_INDUEX = 8;
function checkSchedules() {
  const date = new Date();
  const hour = date.getHours();
  const minutes = date.getMinutes() + hour * 60;
  const dayoftheweek = date.getDay();

  let ret = checkSchedule(PRIORITY_SCHEDULE_INDUEX, minutes);
  if (ret !== undefined) {
    sendScheduleToFrontend(ret,date);
    return;
  }
  ret = checkSchedule(dayoftheweek, minutes);
  if (ret !== undefined) {
    sendScheduleToFrontend(ret,date);
    return;
  }

  ret = checkSchedule(GENERAL_SCHEDULE_INDUEX, minutes);
  if (ret !== undefined) {
    sendScheduleToFrontend(ret,date);
    return;
  }
}


function sendScheduleToFrontend(scheduleData:any,date:Date) {
  if (
    scheduleData !== undefined &&
    scheduleData.type !== undefined &&
    mainWindow !== undefined
  ) {
    if(scheduleData.type === "CountDown"){
      const currenthours = String(date.getHours()).padStart(2, '0');
      const currentminute = String(date.getMinutes()).padStart(2, '0');
      const currentseconds = String(date.getSeconds()).padStart(2, '0');

      const currentTimeAsString = `${currenthours}:${currentminute}:${currentseconds}`;

      const toDateTime = Date.parse("2019-01-01T"+scheduleData.toTime+":59");
      const currentDateTime = Date.parse("2019-01-01T"+currentTimeAsString);
      const difference = (toDateTime - currentDateTime);
      const diffDate = new Date();
      diffDate.setTime(difference);
      diffDate.setHours(diffDate.getHours()-1);
      diffDate.setMinutes(diffDate.getMinutes()-1);
      diffDate.setSeconds(diffDate.getSeconds()+1);

      const hours = String(diffDate.getHours()).padStart(2, '0');
      const minute = String(diffDate.getMinutes()).padStart(2, '0');
      const seconds = String(diffDate.getSeconds()).padStart(2, '0');

      const ret = `${hours}:${minute}:${seconds}`;

      mainWindow.webContents.send("schedule-change", ret);
      if(scheduleData.message !== undefined){
        mainWindow.webContents.send("message-change", scheduleData.message);
      }else{
        mainWindow.webContents.send("message-change", "");
      }
    }else if(scheduleData.type === "CountUp"){
      const currenthours = String(date.getHours()).padStart(2, '0');
      const currentminute = String(date.getMinutes()).padStart(2, '0');
      const currentseconds = String(date.getSeconds()).padStart(2, '0');

      const currentTimeAsString = `${currenthours}:${currentminute}:${currentseconds}`;

      const fromDateTime = Date.parse("2019-01-01T"+scheduleData.fromTime+":00");
      const currentDateTime = Date.parse("2019-01-01T"+currentTimeAsString);
      

      const difference = (currentDateTime - fromDateTime);
      const diffDate = new Date();
      diffDate.setTime(difference);
      
      //diffDate.setMinutes(diffDate.getMinutes()+1);
      //diffDate.setSeconds(diffDate.getSeconds()-1);
      console.log(diffDate);
      const hours = String(diffDate.getHours()).padStart(2, '0');
      const minute = String(diffDate.getMinutes()).padStart(2, '0');
      const seconds = String(diffDate.getSeconds()).padStart(2, '0');

      const ret = `${hours}:${minute}:${seconds}`;

      mainWindow.webContents.send("schedule-change", ret);
      if(scheduleData.message !== undefined){
        mainWindow.webContents.send("message-change", scheduleData.message);
      }else{
        mainWindow.webContents.send("message-change", "");
      }
    }else if(scheduleData.type === "Message") {
      if(scheduleData.message !== undefined){
        mainWindow.webContents.send("schedule-change", "");
        mainWindow.webContents.send("message-change", scheduleData.message);
      }else {
        mainWindow.webContents.send("schedule-change", "");
        mainWindow.webContents.send("message-change", "");
      }
    }
    
  }
}

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
